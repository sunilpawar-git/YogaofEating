name: CI

on:
  push:
    branches: [ main, development ]
  pull_request:
    branches: [ main, development ]

jobs:
  ios-tests:
    name: iOS Tests
    runs-on: macos-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Show Xcode version
        run: xcodebuild -version
        
      - name: Show Swift version
        run: swift --version
        
      - name: Cache Swift Package Manager dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData
            .build
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-
            
      - name: Resolve Swift Package dependencies
        run: |
          xcodebuild -resolvePackageDependencies \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating"
            
      - name: List available simulators
        run: xcrun simctl list devices available
        
      - name: Get available iOS simulator
        id: simulator
        run: |
          # Try to find an available iPhone simulator by name (more reliable than UUID)
          SIMULATOR_NAME=$(xcrun simctl list devices available | grep -i "iphone" | grep -v "unavailable" | head -1 | sed 's/.*iPhone \([0-9A-Za-z ]*\).*/\1/' | head -1 | xargs)
          
          if [ -n "$SIMULATOR_NAME" ]; then
            # Found a simulator name, construct full name
            FULL_NAME="iPhone $SIMULATOR_NAME"
            echo "simulator_name=$FULL_NAME" >> $GITHUB_OUTPUT
            echo "Using simulator: $FULL_NAME"
          else
            # Fallback to common simulators
            if xcrun simctl list devices available | grep -q "iPhone 15"; then
              FULL_NAME="iPhone 15"
            elif xcrun simctl list devices available | grep -q "iPhone 14"; then
              FULL_NAME="iPhone 14"
            elif xcrun simctl list devices available | grep -q "iPhone 13"; then
              FULL_NAME="iPhone 13"
            else
              # Last resort: get first iPhone simulator
              FULL_NAME=$(xcrun simctl list devices available | grep -i "iphone" | head -1 | sed 's/.*(\([^)]*\)).*/\1/' | head -1)
            fi
            echo "simulator_name=$FULL_NAME" >> $GITHUB_OUTPUT
            echo "Using simulator: $FULL_NAME"
          fi
          
      - name: Boot Simulator
        run: |
          if [ -n "${{ steps.simulator.outputs.simulator_name }}" ]; then
            echo "Booting simulator: ${{ steps.simulator.outputs.simulator_name }}"
            xcrun simctl boot "${{ steps.simulator.outputs.simulator_name }}" 2>/dev/null || echo "Simulator may already be booted"
          fi
          
      - name: Build and Test iOS App
        run: |
          # Use device name instead of UUID for better reliability
          DESTINATION="platform=iOS Simulator,name=${{ steps.simulator.outputs.simulator_name }},OS=latest"
          echo "Building with destination: $DESTINATION"
          
          xcodebuild clean test \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating" \
            -destination "$DESTINATION" \
            -only-testing:"Yoga of EatingTests" \
            -configuration Debug \
            -enableCodeCoverage YES \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
            
      - name: Run UI tests (optional - may be flaky)
        continue-on-error: true
        run: |
          DESTINATION="platform=iOS Simulator,name=${{ steps.simulator.outputs.simulator_name }},OS=latest"
          echo "Running UI tests with destination: $DESTINATION"
          
          xcodebuild test \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating" \
            -destination "$DESTINATION" \
            -only-testing:"Yoga of EatingUITests" \
            -configuration Debug \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
            
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            ~/Library/Developer/Xcode/DerivedData/*/Logs/Test/*.xcresult
          retention-days: 7

  firebase-functions-tests:
    name: Firebase Functions Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          cache-dependency-path: functions/package-lock.json
          
      - name: Install dependencies
        working-directory: ./functions
        run: npm ci
        
      - name: Run linting
        working-directory: ./functions
        run: |
          if [ -f "package.json" ] && grep -q "\"lint\"" package.json; then
            npm run lint
          else
            echo "No lint script found, skipping..."
          fi
        continue-on-error: true
        
      - name: Run tests
        working-directory: ./functions
        run: |
          if [ -f "package.json" ] && grep -q "\"test\"" package.json; then
            npm test
          else
            echo "No test script found, skipping tests..."
          fi
        continue-on-error: true
        
      - name: Verify functions can be loaded
        working-directory: ./functions
        run: |
          node -e "require('./index.js'); console.log('Functions loaded successfully')"
        continue-on-error: true

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret scanning
          
      - name: Run Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          config-path: .gitleaks.toml
          no-git: false
          exit-code: 1
          severity: high
        continue-on-error: true
          
      - name: Check for Firebase Service Account Keys
        run: |
          echo "üîç Scanning for Firebase service account keys..."
          if find . -name "*.json" -type f ! -path "*/node_modules/*" ! -path "*/.build/*" ! -path "*/DerivedData/*" ! -path "*/package-lock.json" ! -path "*/Package.resolved" ! -path "*/.github/**" | xargs grep -l "type.*service_account\|private_key_id\|client_email.*@.*\.iam\.gserviceaccount\.com" 2>/dev/null; then
            echo "‚ùå ERROR: Potential Firebase service account key found!"
            exit 1
          else
            echo "‚úÖ No Firebase service account keys detected"
          fi
          
      - name: Check for GoogleService-Info.plist in repo
        run: |
          echo "üîç Checking for GoogleService-Info.plist files..."
          # Check if file is tracked in git
          if git ls-files | grep -qi "GoogleService-Info.plist"; then
            echo "‚ö†Ô∏è  GoogleService-Info.plist is tracked in git"
            
            # Check if it contains placeholder values (CI-safe)
            if grep -qi "ci-test\|yoga-of-eating-ci\|123456789\|abcdef123456" GoogleService-Info.plist 2>/dev/null; then
              echo "‚úÖ CI placeholder detected, this is acceptable"
            else
              # Check if it contains real-looking API keys (starts with AIza and is long enough)
              if grep -qiE "AIza[0-9A-Za-z_-]{30,}" GoogleService-Info.plist 2>/dev/null; then
                echo "‚ùå ERROR: GoogleService-Info.plist found in repository with REAL credentials!"
                echo "The file contains actual Firebase API keys and should NOT be committed."
                echo ""
                echo "To fix this:"
                echo "1. Remove from git: git rm --cached GoogleService-Info.plist"
                echo "2. Ensure it's in .gitignore"
                echo "3. Commit the removal"
                echo "4. Rotate your Firebase API keys if they were exposed"
                exit 1
              else
                echo "‚ö†Ô∏è  Warning: GoogleService-Info.plist is tracked but credentials look safe"
                echo "Consider removing it from git tracking to be safe"
              fi
            fi
          else
            echo "‚úÖ GoogleService-Info.plist is not tracked in git (correct)"
            # Check if it exists locally but is ignored
            if [ -f "GoogleService-Info.plist" ]; then
              echo "‚ÑπÔ∏è  File exists locally but is properly ignored (this is fine)"
            fi
          fi
          
      - name: Check for hardcoded API keys
        run: |
          echo "üîç Scanning for hardcoded API keys..."
          # Common API key patterns
          PATTERNS=(
            "AIza[0-9A-Za-z_-]{35}"
            "sk-[0-9a-zA-Z]{32,}"
            "xox[baprs]-[0-9a-zA-Z-]{10,48}"
            "AKIA[0-9A-Z]{16}"
            "ya29\.[0-9A-Za-z_-]+"
            "1//[0-9A-Za-z_-]+"
          )
          
          FOUND_SECRET=false
          for pattern in "${PATTERNS[@]}"; do
            if git grep -E "$pattern" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' ':!GoogleService-Info.plist' 2>/dev/null; then
              echo "‚ùå ERROR: Potential API key pattern detected: $pattern"
              FOUND_SECRET=true
            fi
          done
          
          if [ "$FOUND_SECRET" = true ]; then
            echo "‚ùå Security scan failed: Hardcoded API keys detected!"
            exit 1
          else
            echo "‚úÖ No hardcoded API keys detected"
          fi
          
      - name: Check for private keys
        run: |
          echo "üîç Scanning for private keys..."
          if git grep -E "BEGIN (RSA |EC |OPENSSH |DSA |PGP )?PRIVATE KEY" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' 2>/dev/null; then
            echo "‚ùå ERROR: Private key detected in repository!"
            exit 1
          else
            echo "‚úÖ No private keys detected"
          fi
          
      - name: Check for environment files with secrets
        run: |
          echo "üîç Checking for .env files..."
          if git ls-files | grep -E "\.env$|\.env\.(local|production|development)$"; then
            echo "‚ùå ERROR: .env files found in repository!"
            echo "Environment files may contain secrets and should be in .gitignore"
            exit 1
          else
            echo "‚úÖ No .env files found in repository"
          fi
          
      - name: Check for common secret patterns
        run: |
          echo "üîç Scanning for common secret patterns..."
          # Check for common secret variable patterns
          SECRET_PATTERNS=(
            "password\s*=\s*['\"][^'\"]+['\"]"
            "secret\s*=\s*['\"][^'\"]+['\"]"
            "api_key\s*=\s*['\"][^'\"]+['\"]"
            "apikey\s*=\s*['\"][^'\"]+['\"]"
            "access_token\s*=\s*['\"][^'\"]+['\"]"
            "auth_token\s*=\s*['\"][^'\"]+['\"]"
          )
          
          FOUND_SECRET=false
          for pattern in "${SECRET_PATTERNS[@]}"; do
            if git grep -E "$pattern" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' ':!package-lock.json' ':!Package.resolved' 2>/dev/null; then
              echo "‚ö†Ô∏è  Warning: Potential secret pattern detected: $pattern"
              echo "Please review to ensure this is not a real secret"
              # Don't fail on warnings, only on confirmed secrets
            fi
          done
          
          echo "‚úÖ Secret pattern scan completed"
