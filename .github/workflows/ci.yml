name: CI

on:
  push:
    branches: [ main, development ]
  pull_request:
    branches: [ main, development ]

jobs:
  ios-tests:
    name: iOS Tests
    runs-on: macos-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Show Xcode version
        run: xcodebuild -version
        
      - name: Show Swift version
        run: swift --version
        
      - name: Cache Swift Package Manager dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData
            .build
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-
            
      - name: Resolve Swift Package dependencies
        run: |
          xcodebuild -resolvePackageDependencies \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating"
            
      - name: List available simulators
        run: xcrun simctl list devices available
        
      - name: Get available iOS simulator
        id: simulator
        run: |
          echo "üîç Detecting available iOS simulator..."
          
          # Preferred: iPhone 17 Pro with iOS 26.2 (project requirement)
          PREFERRED_SIMULATOR="iPhone 17 Pro"
          PREFERRED_OS="26.2"
          
          # Check if iPhone 17 Pro with iOS 26.2 exists
          if xcrun simctl list devices available | grep -qiE "$PREFERRED_SIMULATOR.*26\.2|26\.2.*$PREFERRED_SIMULATOR"; then
            FOUND_SIMULATOR="$PREFERRED_SIMULATOR"
            FOUND_OS="$PREFERRED_OS"
            echo "‚úÖ Found preferred: $FOUND_SIMULATOR with iOS $FOUND_OS"
          else
            echo "‚ö†Ô∏è  iPhone 17 Pro with iOS 26.2 not found, checking alternatives..."
            
            # Check if iPhone 17 Pro exists with any OS version
            IPHONE_17_PRO_LINE=$(xcrun simctl list devices available | grep -i "iPhone 17 Pro" | head -1)
            if [ -n "$IPHONE_17_PRO_LINE" ]; then
              # Extract OS version from the line (format: "iPhone 17 Pro (UUID) (iOS 18.2)")
              EXTRACTED_OS=$(echo "$IPHONE_17_PRO_LINE" | grep -oE "iOS [0-9]+\.[0-9]+" | head -1 | sed 's/iOS //')
              if [ -n "$EXTRACTED_OS" ]; then
                FOUND_SIMULATOR="$PREFERRED_SIMULATOR"
                FOUND_OS="$EXTRACTED_OS"
                echo "‚úÖ Found iPhone 17 Pro with iOS $FOUND_OS (fallback)"
              fi
            fi
            
            # If still not found, try other simulators
            if [ -z "$FOUND_SIMULATOR" ]; then
              echo "‚ö†Ô∏è  iPhone 17 Pro not available, searching for other iPhones..."
              ALTERNATIVES=("iPhone 17" "iPhone 16 Pro" "iPhone 16" "iPhone 15 Pro" "iPhone 15" "iPhone 14")
              
              for sim in "${ALTERNATIVES[@]}"; do
                SIM_LINE=$(xcrun simctl list devices available | grep -i "$sim" | head -1)
                if [ -n "$SIM_LINE" ]; then
                  # Extract device name and OS version
                  FOUND_SIMULATOR=$(echo "$SIM_LINE" | awk -F'(' '{print $1}' | xargs)
                  EXTRACTED_OS=$(echo "$SIM_LINE" | grep -oE "iOS [0-9]+\.[0-9]+" | head -1 | sed 's/iOS //')
                  if [ -n "$EXTRACTED_OS" ]; then
                    FOUND_OS="$EXTRACTED_OS"
                  else
                    FOUND_OS=""  # Let xcodebuild use default
                  fi
                  echo "‚úÖ Found alternative: $FOUND_SIMULATOR with iOS ${FOUND_OS:-default}"
                  break
                fi
              done
            fi
            
            # Last resort: get first available iPhone without OS specification
            if [ -z "$FOUND_SIMULATOR" ]; then
              echo "‚ö†Ô∏è  Searching for any available iPhone..."
              FIRST_IPHONE_LINE=$(xcrun simctl list devices available | grep -i "iphone" | head -1)
              if [ -n "$FIRST_IPHONE_LINE" ]; then
                FOUND_SIMULATOR=$(echo "$FIRST_IPHONE_LINE" | awk -F'(' '{print $1}' | xargs)
                EXTRACTED_OS=$(echo "$FIRST_IPHONE_LINE" | grep -oE "iOS [0-9]+\.[0-9]+" | head -1 | sed 's/iOS //')
                FOUND_OS="${EXTRACTED_OS:-}"
                echo "‚úÖ Found: $FOUND_SIMULATOR with iOS ${FOUND_OS:-default}"
              fi
            fi
          fi
          
          if [ -z "$FOUND_SIMULATOR" ]; then
            echo "‚ùå ERROR: No iPhone simulator found!"
            echo "Available devices:"
            xcrun simctl list devices
            exit 1
          fi
          
          echo "simulator_name=$FOUND_SIMULATOR" >> $GITHUB_OUTPUT
          if [ -n "$FOUND_OS" ]; then
            echo "simulator_os=$FOUND_OS" >> $GITHUB_OUTPUT
          else
            echo "simulator_os=" >> $GITHUB_OUTPUT
          fi
          echo "‚úÖ Selected: $FOUND_SIMULATOR${FOUND_OS:+ with iOS $FOUND_OS}"
          
      - name: Boot Simulator
        run: |
          SIMULATOR_NAME="${{ steps.simulator.outputs.simulator_name }}"
          if [ -n "$SIMULATOR_NAME" ]; then
            echo "Booting simulator: $SIMULATOR_NAME"
            # Boot by name (simctl will find the matching device)
            xcrun simctl boot "$SIMULATOR_NAME" 2>/dev/null || echo "Simulator may already be booted or boot failed (will continue)"
          fi
          
      - name: Build and Test iOS App
        run: |
          SIMULATOR_NAME="${{ steps.simulator.outputs.simulator_name }}"
          SIMULATOR_OS="${{ steps.simulator.outputs.simulator_os }}"
          
          # Build destination string - include OS only if specified
          if [ -n "$SIMULATOR_OS" ] && [ "$SIMULATOR_OS" != "" ]; then
            DESTINATION="platform=iOS Simulator,name=$SIMULATOR_NAME,OS=$SIMULATOR_OS"
          else
            DESTINATION="platform=iOS Simulator,name=$SIMULATOR_NAME"
          fi
          
          echo "Building with destination: $DESTINATION"
          
          xcodebuild clean test \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating" \
            -destination "$DESTINATION" \
            -only-testing:"Yoga of EatingTests" \
            -configuration Debug \
            -enableCodeCoverage YES \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
            
      - name: Run UI tests (optional - only on main branch)
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        continue-on-error: true
        run: |
          echo "üß™ Running UI tests (optional - may be flaky)"
          SIMULATOR_NAME="${{ steps.simulator.outputs.simulator_name }}"
          SIMULATOR_OS="${{ steps.simulator.outputs.simulator_os }}"
          
          # Build destination string - include OS only if specified
          if [ -n "$SIMULATOR_OS" ] && [ "$SIMULATOR_OS" != "" ]; then
            DESTINATION="platform=iOS Simulator,name=$SIMULATOR_NAME,OS=$SIMULATOR_OS"
          else
            DESTINATION="platform=iOS Simulator,name=$SIMULATOR_NAME"
          fi
          
          echo "Running UI tests with destination: $DESTINATION"
          
          xcodebuild test \
            -project "Yoga of Eating.xcodeproj" \
            -scheme "Yoga of Eating" \
            -destination "$DESTINATION" \
            -only-testing:"Yoga of EatingUITests" \
            -configuration Debug \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
          
      - name: Skip UI tests (info)
        if: github.ref != 'refs/heads/main' && github.event_name != 'workflow_dispatch'
        run: |
          echo "‚è≠Ô∏è  Skipping UI tests (only run on main branch or manual workflow dispatch)"
          echo "üí° To run UI tests manually, use 'workflow_dispatch' event or push to main branch"
            
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            ~/Library/Developer/Xcode/DerivedData/*/Logs/Test/*.xcresult
          retention-days: 7

  firebase-functions-tests:
    name: Firebase Functions Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          cache-dependency-path: functions/package-lock.json
          
      - name: Install dependencies
        working-directory: ./functions
        run: npm ci
        
      - name: Run linting
        working-directory: ./functions
        run: |
          if [ -f "package.json" ] && grep -q "\"lint\"" package.json; then
            npm run lint
          else
            echo "No lint script found, skipping..."
          fi
        continue-on-error: true
        
      - name: Run tests
        working-directory: ./functions
        run: |
          if [ -f "package.json" ] && grep -q "\"test\"" package.json; then
            npm test
          else
            echo "No test script found, skipping tests..."
          fi
        continue-on-error: true
        
      - name: Verify functions can be loaded
        working-directory: ./functions
        run: |
          node -e "require('./index.js'); console.log('Functions loaded successfully')"
        continue-on-error: true

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret scanning
          
      - name: Run Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          config-path: .gitleaks.toml
          no-git: false
          exit-code: 1
          severity: high
        continue-on-error: true
          
      - name: Check for Firebase Service Account Keys
        run: |
          echo "üîç Scanning for Firebase service account keys..."
          if find . -name "*.json" -type f ! -path "*/node_modules/*" ! -path "*/.build/*" ! -path "*/DerivedData/*" ! -path "*/package-lock.json" ! -path "*/Package.resolved" ! -path "*/.github/**" | xargs grep -l "type.*service_account\|private_key_id\|client_email.*@.*\.iam\.gserviceaccount\.com" 2>/dev/null; then
            echo "‚ùå ERROR: Potential Firebase service account key found!"
            exit 1
          else
            echo "‚úÖ No Firebase service account keys detected"
          fi
          
      - name: Check for GoogleService-Info.plist in repo
        run: |
          echo "üîç Checking for GoogleService-Info.plist files..."
          # Check if file is tracked in git
          if git ls-files | grep -qi "GoogleService-Info.plist"; then
            echo "‚ö†Ô∏è  GoogleService-Info.plist is tracked in git"
            
            # Check if it contains placeholder values (CI-safe)
            if grep -qi "ci-test\|yoga-of-eating-ci\|123456789\|abcdef123456" GoogleService-Info.plist 2>/dev/null; then
              echo "‚úÖ CI placeholder detected, this is acceptable"
            else
              # Check if it contains real-looking API keys (starts with AIza and is long enough)
              if grep -qiE "AIza[0-9A-Za-z_-]{30,}" GoogleService-Info.plist 2>/dev/null; then
                echo "‚ùå ERROR: GoogleService-Info.plist found in repository with REAL credentials!"
                echo "The file contains actual Firebase API keys and should NOT be committed."
                echo ""
                echo "To fix this:"
                echo "1. Remove from git: git rm --cached GoogleService-Info.plist"
                echo "2. Ensure it's in .gitignore"
                echo "3. Commit the removal"
                echo "4. Rotate your Firebase API keys if they were exposed"
                exit 1
              else
                echo "‚ö†Ô∏è  Warning: GoogleService-Info.plist is tracked but credentials look safe"
                echo "Consider removing it from git tracking to be safe"
              fi
            fi
          else
            echo "‚úÖ GoogleService-Info.plist is not tracked in git (correct)"
            # Check if it exists locally but is ignored
            if [ -f "GoogleService-Info.plist" ]; then
              echo "‚ÑπÔ∏è  File exists locally but is properly ignored (this is fine)"
            fi
          fi
          
      - name: Check for hardcoded API keys
        run: |
          echo "üîç Scanning for hardcoded API keys..."
          # Common API key patterns
          PATTERNS=(
            "AIza[0-9A-Za-z_-]{35}"
            "sk-[0-9a-zA-Z]{32,}"
            "xox[baprs]-[0-9a-zA-Z-]{10,48}"
            "AKIA[0-9A-Z]{16}"
            "ya29\.[0-9A-Za-z_-]+"
            "1//[0-9A-Za-z_-]+"
          )
          
          FOUND_SECRET=false
          for pattern in "${PATTERNS[@]}"; do
            if git grep -E "$pattern" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' ':!GoogleService-Info.plist' 2>/dev/null; then
              echo "‚ùå ERROR: Potential API key pattern detected: $pattern"
              FOUND_SECRET=true
            fi
          done
          
          if [ "$FOUND_SECRET" = true ]; then
            echo "‚ùå Security scan failed: Hardcoded API keys detected!"
            exit 1
          else
            echo "‚úÖ No hardcoded API keys detected"
          fi
          
      - name: Check for private keys
        run: |
          echo "üîç Scanning for private keys..."
          if git grep -E "BEGIN (RSA |EC |OPENSSH |DSA |PGP )?PRIVATE KEY" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' 2>/dev/null; then
            echo "‚ùå ERROR: Private key detected in repository!"
            exit 1
          else
            echo "‚úÖ No private keys detected"
          fi
          
      - name: Check for environment files with secrets
        run: |
          echo "üîç Checking for .env files..."
          if git ls-files | grep -E "\.env$|\.env\.(local|production|development)$"; then
            echo "‚ùå ERROR: .env files found in repository!"
            echo "Environment files may contain secrets and should be in .gitignore"
            exit 1
          else
            echo "‚úÖ No .env files found in repository"
          fi
          
      - name: Check for common secret patterns
        run: |
          echo "üîç Scanning for common secret patterns..."
          # Check for common secret variable patterns
          SECRET_PATTERNS=(
            "password\s*=\s*['\"][^'\"]+['\"]"
            "secret\s*=\s*['\"][^'\"]+['\"]"
            "api_key\s*=\s*['\"][^'\"]+['\"]"
            "apikey\s*=\s*['\"][^'\"]+['\"]"
            "access_token\s*=\s*['\"][^'\"]+['\"]"
            "auth_token\s*=\s*['\"][^'\"]+['\"]"
          )
          
          FOUND_SECRET=false
          for pattern in "${SECRET_PATTERNS[@]}"; do
            if git grep -E "$pattern" -- ':!*.md' ':!.github/**' ':!*.gitignore' ':!*.gitleaks.toml' ':!package-lock.json' ':!Package.resolved' 2>/dev/null; then
              echo "‚ö†Ô∏è  Warning: Potential secret pattern detected: $pattern"
              echo "Please review to ensure this is not a real secret"
              # Don't fail on warnings, only on confirmed secrets
            fi
          done
          
          echo "‚úÖ Secret pattern scan completed"
